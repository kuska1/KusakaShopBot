import os
import os.path
import sys
import time
import datetime
import re
import logging
import subprocess
import geocoder
import requests
import random
import traceback
import json
import html
import hashlib
import base64
from captcha.image import ImageCaptcha
from typing import Optional, Tuple
from traceback import format_exc as F_err
from random import randrange, choice
from html import escape
from uuid import uuid4

from telegram import __version__ as TG_VER

try:
	from telegram import __version_info__
except ImportError:
	__version_info__ = (0, 0, 0, 0, 0)  #Type: ignore[assignment]

class bcolors:
	PINK = '\033[95m'
	BLUE = '\033[94m'
	CYAN = '\033[96m'
	GREEN = '\033[92m'
	YELLOW = '\033[93m'
	RED = '\033[91m'
	GRAY = '\033[90m'
	ENDC = '\033[0m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'
	NEGATIVE1 = '\033[3m'
	NEGATIVE2 = '\033[5m'
	PINKBG = '\033[45m'
	BLUEBG = '\033[44m'
	CYANBG = '\033[46m'
	GREENBG = '\033[42m'
	YELLOWBG = '\033[43m'
	REDBG = '\033[41m'
	GRAYBG = '\033[47m'
	
class clogs:
	INFO = '\033[96m'
	WARNING = '\033[93m'
	ERROR = '\033[91m'
	CRITICAL = '\033[41m'
	DEBUG = '\033[95m'
	BOLD = '\033[1m'
	ENDC = '\033[0m'

if __version_info__ < (20, 0, 0, "alpha", 1):
	import webbrowser
	webbrowser.open(f'https://docs.python-telegram-bot.org/en/v{TG_VER}')
	raise RuntimeError(
		f"\n\n"
		f""+bcolors.RED+""
		f"ERROR | It's look like your PTB version {TG_VER} < 20\n"
		f""+bcolors.CYAN+""
		f'INFO | Visit "https://docs.python-telegram-bot.org/en/v{TG_VER}/"'
		f""+bcolors.ENDC+""
	)

from telegram import ForceReply, Chat, ChatMember, ChatMemberUpdated, WebAppInfo, InlineKeyboardButton, InlineQueryResultArticle, InlineKeyboardMarkup, LabeledPrice, ShippingOption, InputTextMessageContent, Update, helpers
from telegram.constants import ParseMode
from telegram.ext import Application, CallbackQueryHandler, InlineQueryHandler, CommandHandler, ContextTypes, MessageHandler, ChatMemberHandler, filters, PreCheckoutQueryHandler, ShippingQueryHandler, ConversationHandler

print(bcolors.CYAN+'INFO | Please wait...')


#botinfo
onUpdate = False
intversion = 1
version = "V1"
pid = "Unkown"
starttime = time.time()
uptime = time.time() - starttime
imports = [m.__name__ for m in sys.modules.values() if m]
botevents = []

#permissions
ownerID = 0 #Write your own id
adminID = [0] #Write admin ids
logchannel = ownerID #Write channel id to log

#Tokens
TelegramBotToken = '0' #Write your telegram bot token
DonatelloToToken = "0" #Write your payment tokens

#Check info about script, device, host
restartsec = 0
def infocheck():
	global restartsec
	global pid
	from progress.bar import Bar
	from datetime import datetime
	print(bcolors.BLUE + bcolors.BOLD)
	checking = Bar('INFO | Checking...', max=100, fill='=', suffix='%(index)d%% | %(eta)ds')
	for i in range(100):
		time.sleep(random.uniform(0.001, 0.01))
		checking.next()
	try:
		pypiget = requests.get('https://pypi.org/rss/project/python-telegram-bot/releases.xml')
	except:
		print(bcolors.RED + "\nERROR | Internet connection error! Restarting in "+str(restartsec)+" seconds...")
		restartsec += 1
		time.sleep(restartsec)
		infocheck()
	pypitext = pypiget.text
	pypisplit = pypitext.split('\n')
	pypiver = pypisplit[8]
	pypilink = pypisplit[9]
	pypiver = pypiver.replace("<title>", "")
	pypiver = pypiver.replace("</title>", "")
	pypiver = pypiver.replace(" ", "")
	pypilink = pypilink.replace("<link>", "")
	pypilink = pypilink.replace("</link>", "")
	pypilink = pypilink.replace(" ", "")
	try:
		int(float(pypiver))
		if int(float(pypiver)) < 20.00:
			pypiver = TG_VER
	except:
		pypiver = pypiver
	print(bcolors.ENDC + bcolors.CYAN + '\n\nINFO | ' + str(os.uname()))
	print(bcolors.ENDC + bcolors.CYAN + 'INFO | Imports: ' + bcolors.BOLD + str(len(imports)))
	if TG_VER == pypiver:
		print(bcolors.ENDC + bcolors.CYAN + 'INFO | Python-Telegram-Bot Version: ' + bcolors.BOLD + TG_VER + bcolors.ENDC + bcolors.GREEN + ' (Latest)')
	else:
		print(bcolors.ENDC + bcolors.CYAN + 'INFO | Python-Telegram-Bot Version: ' + bcolors.BOLD + TG_VER + bcolors.ENDC + bcolors.YELLOW + ' (' + pypiver + ' available)')
		print(bcolors.ENDC + bcolors.BLUE + 'LINK | ' + pypilink + '')
		print(bcolors.ENDC + bcolors.BLUE + 'LINK | https://docs.python-telegram-bot.org/en/' + pypiver + '/')
	print(bcolors.ENDC + bcolors.CYAN + 'INFO | Bot Version: ' + bcolors.BOLD + str(version))
	if os.path.exists("database.json") == False:
		print(bcolors.ENDC + bcolors.YELLOW + 'INFO | database.json not founded')
		data_create = open("database.json","w")
		data_create.write("{}")
		data_create.close()
		print(bcolors.ENDC + bcolors.GREEN + 'INFO | database.json created and saved')
	else:
		filestats = os.stat("database.json")
		try:
			data = json.loads(open("database.json","r").read())
			print(bcolors.ENDC + bcolors.CYAN + 'INFO | database.json '+bcolors.BOLD+'('+str(filestats.st_size)+'B)'+bcolors.ENDC+bcolors.CYAN+' founded and loaded')
		except:
			print(bcolors.ENDC + bcolors.YELLOW + 'WARNING | database.json '+bcolors.BOLD+'('+str(filestats.st_size)+'B)'+bcolors.ENDC+bcolors.YELLOW+' not loaded!')
			time.sleep(5)
	if os.path.exists("shop.json") == False:
		print(bcolors.ENDC + bcolors.YELLOW + 'INFO | shop.json not founded')
		data_create = open("shop.json","w")
		x = {
			"items":{
				"item":[],
				"price":[],
				"discount":[],
				"amount":[],
				"com":[],
				"purchase":[]
			},
			"codes":{
				"code":[],
				"value":[],
				"amount":[],
				"com":[]
			},
			"payment":{
				"list":[],
				"enabled":[]
			},
		}
		json.dump(x, open("shop.json","w"))
		print(bcolors.ENDC + bcolors.GREEN + 'INFO | shop.json created and saved')
	else:
		filestats = os.stat("shop.json")
		try:
			data = json.loads(open("shop.json","r").read())
			print(bcolors.ENDC + bcolors.CYAN + 'INFO | shop.json '+bcolors.BOLD+'('+str(filestats.st_size)+'B)'+bcolors.ENDC+bcolors.CYAN+' founded and loaded\n')
		except:
			print(bcolors.ENDC + bcolors.YELLOW + 'WARNING | shop.json '+bcolors.BOLD+'('+str(filestats.st_size)+'B)'+bcolors.ENDC+bcolors.YELLOW+' not loaded!\n')
			time.sleep(5)
	if os.path.exists("stock.json") == False:
		print(bcolors.ENDC + bcolors.YELLOW + 'INFO | stock.json not founded')
		data_create = open("stock.json","w")
		x = {
			"X":[""],
		}
		json.dump(x, open("stock.json","w"))
		print(bcolors.ENDC + bcolors.GREEN + 'INFO | stock.json created and saved')
	else:
		filestats = os.stat("stock.json")
		try:
			data = json.loads(open("stock.json","r").read())
			print(bcolors.ENDC + bcolors.CYAN + 'INFO | stock.json '+bcolors.BOLD+'('+str(filestats.st_size)+'B)'+bcolors.ENDC+bcolors.CYAN+' founded and loaded\n')
		except:
			print(bcolors.ENDC + bcolors.YELLOW + 'WARNING | stock.json '+bcolors.BOLD+'('+str(filestats.st_size)+'B)'+bcolors.ENDC+bcolors.YELLOW+' not loaded!\n')
			time.sleep(5)
	try:
		os.getlogin()
		pid = str(os.getpid())
	except:
		pid = 'Hosted'
	print(bcolors.GREEN + "\nINFO | All correct!")
	print(bcolors.ENDC)

infocheck()

def containsNumber(value):
	for character in value:
		if character.isdigit():
			return True
	return False

def is_integer_num(n):
	if isinstance(n, int):
		return True
	if isinstance(n, float):
		return n.is_integer()
	return False



#Enable logging
logformatI = clogs.BOLD+"%(levelname)s | %(asctime)s | %(name)s - %(message)s"+clogs.ENDC
logformatW = clogs.BOLD+clogs.WARNING+"%(levelname)s | %(asctime)s | %(name)s - %(message)s"+clogs.ENDC
logformatE = clogs.BOLD+clogs.ERROR+"%(levelname)s | %(asctime)s | %(name)s - %(message)s"+clogs.ENDC
logformatC = clogs.BOLD+clogs.CRITICAL+"%(levelname)s | %(asctime)s | %(name)s - %(message)s"+clogs.ENDC
logformatD = clogs.BOLD+clogs.DEBUG+"%(levelname)s | %(asctime)s | %(name)s - %(message)s"+clogs.ENDC

logging.basicConfig(
	format=logformatI, level=logging.INFO
)
logging.basicConfig(
	format=logformatW, level=logging.WARNING
)
logging.basicConfig(
	format=logformatE, level=logging.ERROR
)
logging.basicConfig(
	format=logformatC, level=logging.CRITICAL
)
logging.basicConfig(
	format=logformatD, level=logging.DEBUG
)
logger = logging.getLogger(__name__)



#Define a few command handlers. These usually take the two arguments update and context.

if onUpdate == True:
			async def onUpdate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
				await update.message.reply_text(f'üî® *{context.bot.first_name}* is on update.\nüïì Wait some time!\n‚öôÔ∏è Version: *' + version + '*', parse_mode= 'Markdown')



async def querybuttons(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	keyboard = [
		[
			InlineKeyboardButton("0", callback_data="0"),
			InlineKeyboardButton("1", callback_data="1"),
			InlineKeyboardButton("2", callback_data="2"),
		],
		[
			InlineKeyboardButton("3", callback_data="3"),
			InlineKeyboardButton("4", callback_data="4"),
			InlineKeyboardButton("5", callback_data="5"),
		],
		[
			InlineKeyboardButton("6", callback_data="6"),
			InlineKeyboardButton("7", callback_data="7"),
			InlineKeyboardButton("8", callback_data="8"),
		],
		[InlineKeyboardButton("9", callback_data="9")],
	]
	buttons = InlineKeyboardMarkup(keyboard)
	
	query = update.callback_query
	await query.answer()
	if query.data == 'profile':
		user = str(query.from_user.id)
		us = query.from_user
		data = json.loads(open("database.json","r").read())
		balance = data[user]["balance"]
		transaction = data[user]["transactions"]
		item = transaction["item"]
		price = transaction["price"]
		item = item[len(item)-1]
		price = price[len(price)-1]
		lang = data[user]["lang"]
		if lang == 'ru':
			refill = "–ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å"
			shop = "–ú–∞–≥–∞–∑–∏–Ω"
			settings = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏"
			text = f'üåÄ –¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å\nüë§ –ù–∏–∫: <b>{us.username}</b>\nüÜî –ê–π–¥–∏: <b>{us.id}</b>\nüí≥ –ë–∞–ª–∞–Ω—Å: <b>{balance}</b>‚Ç¥\nüìë –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è: <b>{item}</b> ({price}‚Ç¥)\nüá∑üá∫ –Ø–∑—ã–∫: <b>{lang}</b>'
		elif lang == 'uk':
			refill = "–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å"
			shop = "–ú–∞–≥–∞–∑–∏–Ω"
			settings = "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è"
			text = f'üåÄ –¢–≤—ñ–π –ø—Ä–æ—Ñ—ñ–ª—å\nüë§ –ù—ñ–∫: <b>{us.username}</b>\nüÜî –ê–π–¥—ñ: <b>{us.id}</b>\nüí≥ –ë–∞–ª–∞–Ω—Å: <b>{balance}</b>‚Ç¥\nüìë –û—Å—Ç–∞–Ω–Ω—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è: <b>{item}</b> ({price}‚Ç¥)\nüá∫üá¶ –ú–æ–≤–∞: <b>{lang}</b>'
		else:
			refill = "Refill balance"
			shop = "Shop"
			settings = "Settings"
			text = f'üåÄ Your profile\nüë§ Nickname: <b>{us.username}</b>\nüÜî ID: <b>{us.id}</b>\nüí≥ Balance: <b>{balance}</b>‚Ç¥\nüìë Last transaction: <b>{item}</b> ({price}‚Ç¥)\nüá∫üá∏ Language: <b>{lang}</b>'
		profilekeyboard = [
			[InlineKeyboardButton(f"üí∏ {refill}", callback_data="refillbalance")],
			[InlineKeyboardButton(f"üõç {shop}", callback_data="shop")],
			[InlineKeyboardButton(f"‚öôÔ∏è {settings}", callback_data="settings")],
		]
		profilebuttons = InlineKeyboardMarkup(profilekeyboard)
		await query.edit_message_text(text, parse_mode=ParseMode.HTML, reply_markup=profilebuttons)
	if query.data == 'refillbalance':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã"
			s_back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = "–û–±–µ—Ä—ñ—Ç—å —Å–ø–æ—Å—ñ–± –æ–ø–ª–∞—Ç–∏"
			s_back = "–ù–∞–∑–∞–¥"
		else:
			text = "Select a payment method"
			s_back = "Back"
		data_shop = json.loads(open("shop.json","r").read())
		keyboard = []
		for i in range(len(data_shop["payment"]["list"])):
			l = data_shop["payment"]["list"][i]
			if data_shop["payment"]["enabled"][i] == "True":
				if l == "donatello":
					keyboard += [
						[InlineKeyboardButton(f"üá∫üá¶ Donatello", callback_data="r_donatello")],
					]
				else:
					keyboard += [
						[InlineKeyboardButton(f"üá¶üá¶ {l.title()}", callback_data=f"r_{l}")],
					]
		keyboard += [
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üí∏ {text}", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 'r_donatello':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = f"–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ –∏ –æ–ø–ª–∞—Ç–∏—Ç–µ —É–∫–∞–∑–∞–≤ –≤ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–∞—à *–∞–π–¥–∏*! –í–∞—à –∞–π–¥–∏: `{user}`"
			s_check = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –º–æ–π –ø–ª–∞—Ç√´–∂"
			s_cancel = "–û—Ç–º–µ–Ω–∏—Ç—å"
			wait = "–ü–æ–¥–æ–∂–¥–∏—Ç–µ"
		elif lang_data == 'uk':
			text = f"–ü–µ—Ä–µ–π–¥—ñ—Ç—å –ø–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—é –Ω–∏–∂—á–µ —Ç–∞ —Å–ø–ª–∞—Ç—ñ—Ç—å –≤–∫–∞–∑–∞–≤ —É —ñ–º–µ–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤–∞—à *–∞–π–¥—ñ*! –í–∞—à –∞–π–¥—ñ: `{user}`"
			s_check = "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –º—ñ–π –ø–ª–∞—Ç—ñ–∂"
			s_cancel = "–í—ñ–¥–º—ñ–Ω–∏—Ç–∏"
			wait = "–ó–∞—á–µ–∫–∞–π—Ç–µ"
		else:
			text = f"Follow the link below and pay with your *ID* in your username! Your ID: `{user}`"
			s_check = "Check my payment"
			s_cancel = "Cancel"
			wait = "Wait"
		await query.edit_message_text(f"üïì {wait}...", parse_mode='Markdown')
		data = {
			"X-Token":DonatelloToToken,
		}
		req = requests.get('https://donatello.to/api/v1/me', headers=data)
		t = json.loads(req.text)
		link = t["page"]
		keyboard = [
			[InlineKeyboardButton(f"‚úÖ {s_check}", callback_data=f"r_check_{query.data}")],
			[InlineKeyboardButton(f"‚ùé {s_cancel}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üí∏ {text}\nüîó {link}", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 'shop':
		if "_p" in query.data:
			qdata = query.data
			qdsplit = qdata.split('_')
			q1 = qdsplit[0]
			q2 = qdsplit[1]
			shop_page = q2
		else:
			shop_page = "1"
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä"
			TTamount = "–ö–æ–ª-–≤–æ"
			NoneItems = "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Ç–æ–≤–∞—Ä–æ–≤ –Ω–µ—Ç—É, –ø—Ä–∏—Ö–æ–¥–∏—Ç–µ –ø–æ–∑–∂–µ"
			s_back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = "–û–±–µ—Ä—ñ—Ç—å —Ç–æ–≤–∞—Ä"
			TTamount = "–ö—ñ–ª—å-—Å—Ç—å"
			NoneItems = "–í —Ü–µ–π —á–∞—Å —Ç–æ–≤–∞—Ä—ñ–≤ –Ω–µ–º–∞—î, –ø—Ä–∏—Ö–æ–¥—å—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ"
			s_back = "–ù–∞–∑–∞–¥"
		else:
			text = "Select an item"
			TTamount = "Amount"
			NoneItems = "At this time items is nothing, come back later"
			s_back = "Back"
		shop_data = json.loads(open("shop.json","r").read())
		shop = shop_data["items"]
		am = 0
		TTitems = ''
		keyboard = []
		for i in range(len(shop_data["items"]["item"])):
			Sitem = shop_data["items"]["item"][i]
			if Sitem == "":
				if lang_data == 'ru':
					TTitems = "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Ç–æ–≤–∞—Ä–æ–≤ –Ω–µ—Ç—É, –ø—Ä–∏—Ö–æ–¥–∏—Ç–µ –ø–æ–∑–∂–µ"
				elif lang_data == 'uk':
					TTitems = "–í —Ü–µ–π —á–∞—Å —Ç–æ–≤–∞—Ä—ñ–≤ –Ω–µ–º–∞—î, –ø—Ä–∏—Ö–æ–¥—å—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ"
				else:
					TTitems = "At this time items is nothing, come back later"
				keyboard = [
					[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="profile")],
				]
				buttons = InlineKeyboardMarkup(keyboard)
				await query.edit_message_text(f"üõç {TTitems}", parse_mode=ParseMode.HTML, reply_markup=buttons)
				return
			i = i*int(shop_page)
			Sprice = shop_data["items"]["price"][i]
			Sdiscount = shop_data["items"]["discount"][i]
			Samount = shop_data["items"]["amount"][i]
			Scom = shop_data["items"]["com"][i]
			am = i
			if Samount != 0:
				if am*int(shop_page) == 10*int(shop_page):
					if int(shop_page) > 1:
						keyboard += [
							[InlineKeyboardButton(f"¬´", callback_data="shop_p{str(int(shop_page)-1)}")],
						]
					if int(shop_p)*10 <= len(shop_data["items"]["item"]):
						keyboard += [
							[InlineKeyboardButton(f"¬ª", callback_data="shop_p{str(int(shop_page)+1)}")],
						]
						break
				elif int(shop_page) > 1:
					keyboard += [
						[InlineKeyboardButton(f"¬´", callback_data="shop_p{str(int(shop_page)-1)}")],
					]
				else:
					pass
				mj = ''+random.choice(list('üçèüçéüçêüçäüçãüçåüçâüçáüçìü´êüçàüçíüçëü•≠üççü••ü•ùüçÖüçÜü•ëü•¶ü•¨ü•íüå∂ü´ëüåΩü•ïü´íüßÑüßÖü•îüç†ü•êü•Øüçûü•ñü•®üßÄü•öüç≥üßàü•ûüßáü•ìü•©üçóüçñü¶¥üå≠üçîüçüüçïü´ìü•™ü•ôüßÜüåÆüåØü´îü•óü•òü´ïü•´üçùüçúüç≤üçõüç£üç±ü•üü¶™üç§üçôüçöüçòüç•ü•†ü•Æüç¢üç°üçßüç®üç¶ü•ßüßÅüç∞üéÇüçÆüç≠üç¨üç´üçøüç©üç™üå∞ü•úüçØü•õüçºü´ñ‚òïÔ∏èüçµüßÉü•§üßãüç∂üç∫ü•Çüç∑ü•Éüç∏üçπüßâüçæüßäüßÇ'))
				TTitems += f"\n{str(am+1)}. <b>{Sitem}</b> - "
				if Sdiscount == 0:
					TTitems += f"<b>{Sprice}‚Ç¥</b>"
				else:
					TTitems += f"<b>{Sprice}‚Ç¥</b> <i>(-{Sdiscount}%)</i>"
				if Samount != -1:
					TTitems += f" | {TTamount}: <b>{Samount}</b>"
				if Scom != "":
					TTitems += f" | <i>{Scom}</i>"
				keyboard += [
					[InlineKeyboardButton(f"{str(mj)} {str(Sitem)} ({str(Sprice)}‚Ç¥)", callback_data=f"shop_ask_item_{str(i)}")],
				]
		keyboard += [
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üõç {text}{TTitems}", parse_mode=ParseMode.HTML, reply_markup=buttons)
	if "shop_ask_item_" in query.data:
		qdata = query.data
		qdsplit = qdata.split('_')
		q1 = qdsplit[0]
		q2 = qdsplit[1]
		q3 = qdsplit[2]
		q4 = qdsplit[3]
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		shop_data = json.loads(open("shop.json","r").read())
		q4 = int(q4)
		Sitem = shop_data["items"]["item"][q4]
		Sprice = shop_data["items"]["price"][q4]
		Sdiscount = shop_data["items"]["discount"][q4]
		Samount = shop_data["items"]["amount"][q4]
		Scom = shop_data["items"]["com"][q4]
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = f"–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ *{Sitem}* –∑–∞ *{str(Sprice)}‚Ç¥*?"
			c_yes = "–î–∞"
			c_no = "–ù–µ—Ç"
			back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = f"–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ —â–æ —Ö–æ—á–µ—Ç–µ –∫—É–ø–∏—Ç–∏ *{Sitem}* –∑–∞ *{str(Sprice)}‚Ç¥*?"
			c_yes = "–¢–∞–∫"
			c_no = "–ù—ñ"
			back = "–ù–∞–∑–∞–¥"
		else:
			text = f"Do you want buy *{Sitem}* for *{str(Sprice)}‚Ç¥*?"
			c_yes = "Yes"
			c_no = "No"
			back = "Back"
		keyboard = [
			[InlineKeyboardButton(f"‚úÖ {c_yes}", callback_data=f"shop_buy_item_{str(q4)}"),
			InlineKeyboardButton(f"‚ùé {c_no}", callback_data="shop")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üõí {text}", parse_mode='Markdown', reply_markup=buttons)
	if "shop_buy_item_" in query.data:
		qdata = query.data
		qdsplit = qdata.split('_')
		q1 = qdsplit[0]
		q2 = qdsplit[1]
		q3 = qdsplit[2]
		q4 = qdsplit[3]
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		shop_data = json.loads(open("shop.json","r").read())
		q4 = int(q4)
		Ubalance = data[user]["balance"]
		Utransactions = data[user]["transactions"]
		Uitem = data[user]["transactions"]["item"]
		Uprice = data[user]["transactions"]["price"]
		Udate = data[user]["transactions"]["date"]
		Sitem = shop_data["items"]["item"][q4]
		Sprice = shop_data["items"]["price"][q4]
		Sdiscount = shop_data["items"]["discount"][q4]
		Samount = shop_data["items"]["amount"][q4]
		Scom = shop_data["items"]["com"][q4]
		
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			successfully = f"*–£—Å–ø–µ—à–Ω–æ!* –í—ã –ø—Ä–∏–æ–±—Ä–µ–ª–∏ *{Sitem}* –∑–∞ *{str(Sprice)}‚Ç¥*!"
			error_money = "*–û—à–∏–±–∫–∞!* –ù–∞ –≤–∞—à–µ–º —Å—á–µ—Ç—É –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!"
			tutorial = f"–ù–∞–ø–∏—à–∏—Ç–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –∏—Å–ø–æ–ª—å–∑—É—è */support* —á—Ç–æ–± –≤–∞–º –≤—ã–¥–∞–ª–∏ –ø–æ–∫—É–ø–∫—É"
			Sbalance = f"–ë–∞–ª–∞–Ω—Å: *{str(Ubalance-Sprice)}‚Ç¥*"
			Ebalance = f"–ë–∞–ª–∞–Ω—Å: *{str(Ubalance)}‚Ç¥*"
			back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			successfully = f"*–£—Å–ø—ñ—à–Ω–æ!* –í–∏ –∫—É–ø–∏–ª–∏ *{Sitem}* –∑–∞ *{str(Sprice)}‚Ç¥*!"
			error_money = "*–ü–æ–º–∏–ª–∫–∞!* –ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∫–æ—à—Ç—ñ–≤!"
			tutorial = f"–ù–∞–ø–∏—à—ñ—Ç—å —É –ø—ñ–¥—Ç—Ä–∏–º–∫—É –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—è */support* —â–æ–± –≤–∞–º –≤–∏–¥–∞–ª–∏ –ø–æ–∫—É–ø–∫—É"
			Sbalance = f"–ë–∞–ª–∞–Ω—Å: *{str(Ubalance-Sprice)}‚Ç¥*"
			Ebalance = f"–ë–∞–ª–∞–Ω—Å: *{str(Ubalance)}‚Ç¥*"
			back = "–ù–∞–∑–∞–¥"
		else:
			successfully = f"*Successfully!* You bought *{Sitem}* for *{str(Sprice)}‚Ç¥*!"
			error_money = "*Error!* On your balance not enough money!"
			tutorial = f"Write to support using */support* to get your purchase"
			Sbalance = f"–ë–∞–ª–∞–Ω—Å: *{str(Ubalance-Sprice)}‚Ç¥*"
			Ebalance = f"Balance: *{str(Ubalance)}‚Ç¥*"
			back = "Back"
		keyboard = [
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {back}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		if Ubalance >= Sprice:
			from datetime import date
			today = date.today()
			today = str(today)
			Ubalance -= Sprice
			Uitem.append(Sitem)
			Uprice.append(Sprice)
			Udate.append(today)
			data[user]["balance"] = Ubalance
			data[user]["transactions"]["item"] = Uitem
			data[user]["transactions"]["price"] = Uprice
			data[user]["transactions"]["date"] = Udate
			if Samount != -1:
				shop_data["items"]["amount"][q4] -= 1
			json.dump(data, open("database.json","w"))
			json.dump(shop_data, open("shop.json","w"))
			text = f"‚òëÔ∏è {successfully}\nüí≥ {Sbalance}"
			if shop_data["items"]["purchase"][q4] == "/tutorial":
				text += f"\n\n‚ùï {tutorial}"
			await query.edit_message_text(f"{text}", parse_mode='Markdown', reply_markup=buttons)
		else:
			await query.edit_message_text(f"‚ùå {error_money}\nüí≥ {Ebalance}", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 'r_donatello':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = f"–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ –∏ –æ–ø–ª–∞—Ç–∏—Ç–µ —É–∫–∞–∑–∞–≤ –≤ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–∞—à *–∞–π–¥–∏*! –í–∞—à –∞–π–¥–∏: `{user}`"
			s_check = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –º–æ–π –ø–ª–∞—Ç√´–∂"
			s_cancel = "–û—Ç–º–µ–Ω–∏—Ç—å"
			wait = "–ü–æ–¥–æ–∂–¥–∏—Ç–µ"
		elif lang_data == 'uk':
			text = f"–ü–µ—Ä–µ–π–¥—ñ—Ç—å –ø–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—é –Ω–∏–∂—á–µ —Ç–∞ —Å–ø–ª–∞—Ç—ñ—Ç—å –≤–∫–∞–∑–∞–≤ —É —ñ–º–µ–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤–∞—à *–∞–π–¥—ñ*! –í–∞—à –∞–π–¥—ñ: `{user}`"
			s_check = "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –º—ñ–π –ø–ª–∞—Ç—ñ–∂"
			s_cancel = "–í—ñ–¥–º—ñ–Ω–∏—Ç–∏"
			wait = "–ó–∞—á–µ–∫–∞–π—Ç–µ"
		else:
			text = f"Follow the link below and pay with your *ID* in your username! Your ID: `{user}`"
			s_check = "Check my payment"
			s_cancel = "Cancel"
			wait = "Wait"
		await query.edit_message_text(f"üïì {wait}...", parse_mode='Markdown')
		data = {
			"X-Token":DonatelloToToken,
		}
		req = requests.get('https://donatello.to/api/v1/me', headers=data)
		t = json.loads(req.text)
		link = t["page"]
		keyboard = [
			[InlineKeyboardButton(f"‚úÖ {s_check}", callback_data=f"r_check_{query.data}")],
			[InlineKeyboardButton(f"‚ùé {s_cancel}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üí∏ {text}\nüîó {link}", parse_mode='Markdown', reply_markup=buttons)
	if "r_check_" in query.data:
		qdata = query.data
		qdsplit = qdata.split('_')
		q1 = qdsplit[1]
		q2 = qdsplit[2]
		q3 = qdsplit[3]
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		UpubId = data[user]["pubId"]
		Ubalance = data[user]["balance"]
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			wait = '–ü—Ä–æ–≤–µ—Ä—è–µ–º'
			s_back = '–ù–∞–∑–∞–¥'
			error = '*–û—à–∏–±–∫–∞!*'
			error_not_found = f'{error} –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ'
			error_not_available = f'{error} –≠—Ç–æ—Ç —Å–ø–æ—Å–æ–± —Å–µ–π—á–∞—Å –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω'
			error_unknown = f'{error} –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø–ª–∞—Ç√´–∂–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞'
		elif lang_data == 'uk':
			wait = '–ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ'
			s_back = '–ù–∞–∑–∞–¥'
			error = '*–ü–æ–º–∏–ª–∫–∞!*'
			error_not_found = f'{error} –ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ'
			error_not_available = f'{error} –¶–µ–π —Å–ø–æ—Å—ñ–± –Ω–∞ —Ü–µ–π —á–∞—Å –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∏–π'
			error_unknown = f'{error} –ù–µ–≤—ñ–¥–æ–º–∞ –ø–ª–∞—Ç—ñ–∂–Ω–∞ —Å–∏—Å—Ç–µ–º–∞'
		else:
			wait = 'Checking'
			s_back = 'Back'
			error = '*Error!*'
			error_not_found = f'{error} Nothing found'
			error_not_available = f'{error} This payment is not available right now'
			error_unknown = f'{error} Unknown payment system'
		await query.edit_message_text(f"üîé {wait}...", parse_mode='Markdown')
		ERRORQ3 = False
		warning = False
		if q3 == 'donatello':
			try:
				data = {
					"X-Token":DonatelloToToken,
				}
				req = requests.get('https://donatello.to/api/v1/donates', headers=data)
			except:
				keyboard = [
					[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="profile")],
				]
				buttons = InlineKeyboardMarkup(keyboard)
				await query.edit_message_text(f"‚ùå {error_unknown}", parse_mode='Markdown', reply_markup=buttons)
				return
			t = json.loads(req.text)
			content = t["content"]
			l = len(t["content"])
			err = 0
			for i in t["content"]:
				DpubId = i["pubId"]
				DclientName = i["clientName"]
				Damount = i["amount"]
				Dcurrency = i["currency"]
				if str(DclientName) != user:
					err += 1
				else:
					break
			keyboard = [
				[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="profile")],
			]
			buttons = InlineKeyboardMarkup(keyboard)
			if err == l:
				await query.edit_message_text(f"‚ùå {error_not_found}", parse_mode='Markdown', reply_markup=buttons)
				return
		else:
			ERRORQ3 = True
		if lang_data == 'ru':
			successfully = f'*–£—Å–ø–µ—à–Ω–æ!* –ù–∞ –≤–∞—à —Å—á√´—Ç –±—ã–ª–æ –∑–∞—á–∏—Å–ª–µ–Ω–æ *{Damount}*‚Ç¥'
			error = '*–û—à–∏–±–∫–∞!*'
			error_not_found = f'{error} –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ'
			error_qsplit = f'{error} –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø–ª–∞—Ç√´–∂–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞'
			error_currency = f'{error} –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –≤–∞–ª—é—Ç–∞ *{Dcurrency}*, –æ–∂–∏–¥–∞–ª–æ—Å—å *UAH*'
			write = f'–°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∫–µ'
			Tbalance = '–ë–∞–ª–∞–Ω—Å: '
		elif lang_data == 'uk':
			successfully = f'*–£—Å–ø—ñ—à–Ω–æ!* –ù–∞ –≤–∞—à —Ä–∞—Ö—É–Ω–æ–∫ –±—É–ª–æ –∑–∞—Ä–∞—Ö–æ–≤–∞–Ω–æ *{Damount}*‚Ç¥'
			error = '*–ü–æ–º–∏–ª–∫–∞!*'
			error_not_found = f'{error} –ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ'
			error_qsplit = f'{error} –ù–µ–≤—ñ–¥–æ–º–∞ –ø–ª–∞—Ç—ñ–∂–Ω–∞ —Å–∏—Å—Ç–µ–º–∞'
			error_currency = f'{error} –ù–µ–≤—ñ–¥–æ–º–∞ –≤–∞–ª—é—Ç–∞ *{Dcurrency}*, –æ—á–∏–∫—É–≤–∞–ª–∞—Å—å *UAH*'
			write = f'–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –æ–± –ø–æ–º–∏–ª–∫–µ –±—É–ª–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—ñ–¥—Ç—Ä–∏–º—Ü—ñ'
			Tbalance = '–ë–∞–ª–∞–Ω—Å: '
		else:
			successfully = f'*Successfully!* On your account has been added *{Damount}*‚Ç¥'
			error = '*Error!*'
			error_not_found = f'{error} Nothing found'
			error_qsplit = f'{error} Unknown payment system'
			error_currency = f'{error} Unknown currency *{Dcurrency}*, waited for *UAH*'
			write = f'Message with error sended to support'
			Tbalance = 'Balance: '
		if ERRORQ3 == True:
			await query.edit_message_text(f"‚ùå {error_qsplit}", parse_mode='Markdown', reply_markup=buttons)
			return
		else:
			if Dcurrency != "UAH":
				await query.edit_message_text(f"‚ùå {error_currency}\n‚ö†Ô∏è {write}", parse_mode='Markdown', reply_markup=buttons)
				await context.bot.send_message(ownerID, text=f"‚ö†Ô∏è {user} payed {Damount} with unknown currency ({Dcurrency}) | Public ID: {DpubId}")
				print(bcolors.ENDC + bcolors.WARNING + 'PAYMENT | '+user+' payed '+Damount+' ('+Dcurrency+') | ID: '+DpubId+bcolors.ENDC)
				if UpubId[0] == "None":
					UpubId = [DpubId]
				else:
					UpudId.append(DpubId)
				data = json.loads(open("database.json","r").read())
				data[user]["pubId"] = UpudId
				json.dump(data, open("database.json","w"))
				return
			try:
				if str(DclientName) == user:
					if DpubId not in UpubId:
						data = json.loads(open("database.json","r").read())
						try:
							user = context.user_data["user"]
						except:
							user = str(query.from_user.id)
						data = json.loads(open("database.json","r").read())
						UpubId = data[user]["pubId"]
						Ubalance = data[user]["balance"]
						if UpubId[0] == "None":
							UpubId = [DpubId]
						else:
							UpudId.append(DpubId)
						Ubalance += int(Damount)
						data[user]["balance"] = Ubalance
						data[user]["pubId"] = UpubId
						json.dump(data, open("database.json","w"))
						data = json.loads(open("database.json","r").read())
						print(bcolors.ENDC + bcolors.CYAN + 'PAYMENT | '+user+' payed '+Damount+' ('+Dcurrency+') | ID: '+DpubId+bcolors.ENDC)
						try:
							await context.bot.send_message(ownerID, text=f'üí∏ Payment from *{user}* on *{str(Damount)}* _({Dcurrency})_ | ID: *{str(DpudId)}*', parse_mode='Markdown')
						except:
							await context.bot.send_message(ownerID, text=f'üí∏ Test Payment from *{user}* on *{str(Damount)}* _({Dcurrency})_ | ID: *Test*', parse_mode='Markdown')
						await query.edit_message_text(f"‚òëÔ∏è {successfully}\nüí≥ {Tbalance}*{str(Ubalance)}‚Ç¥*\nüßæ Public ID: _{str(DpubId)}_", parse_mode='Markdown', reply_markup=buttons)
					else:
						await query.edit_message_text(f"‚ùå {error_not_found}", parse_mode='Markdown', reply_markup=buttons)
				else:
					await query.edit_message_text(f"‚ùå {error_not_found}", parse_mode='Markdown', reply_markup=buttons)
			except:
				await query.edit_message_text(f"‚ùå {error}\n{F_err()}", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 'settings':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ"
			s_data = "–ú–æ–∏ –¥–∞–Ω–Ω—ã–µ"
			s_checkout = "–ß–µ–∫–∏"
			s_lang = "–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫"
			s_codes = "–ö–æ–¥—ã"
			s_back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂—á–µ"
			s_data = "–ú–æ—ó –¥–∞–Ω—ñ"
			s_checkout = "–ß–µ–∫–∏"
			s_lang = "–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É"
			s_codes = "–ö–æ–¥–∏"
			s_back = "–ù–∞–∑–∞–¥"
		else:
			text = "Use buttons below"
			s_data = "My data"
			s_checkout = "Checkouts"
			s_lang = "Change language"
			s_codes = "Codes"
			s_back = "Back"
		keyboard = [
			[InlineKeyboardButton(f"üóÇ {s_data}", callback_data="s_data")],
			[InlineKeyboardButton(f"üßæ {s_checkout}", callback_data="s_checkout")],
			[InlineKeyboardButton(f"üá¶üá¶ {s_lang}", callback_data="s_lang")],
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"‚öôÔ∏è {text}", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 's_data':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = "–í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ"
			s_back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = "–í–∞—à—ñ –¥–∞–Ω—ñ"
			s_back = "–ù–∞–∑–∞–¥"
		else:
			text = "Your data"
			s_back = "Back"
		keyboard = [
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="settings")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üóÇ {text} *({user})*\n`{str(data[user])}`", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 's_checkout':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = "–í–∞—à–∏ —á–µ–∫–∏"
			s_back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = "–í–∞—à—ñ —á–µ–∫–∏"
			s_back = "–ù–∞–∑–∞–¥"
		else:
			text = "Your checkouts"
			s_back = "Back"
		keyboard = [
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="settings")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		am = 0
		ck = ""
		transaction = data[user]["transactions"]
		item = transaction["item"]
		price = transaction["price"]
		date = transaction["date"]
		if len(item) <=1 and item[0] == "Registration":
			if lang_data == 'ru':
				ck = "*–í—ã –µ—â√´ –Ω–µ –¥–µ–ª–∞–ª–∏ –ø–æ–∫—É–ø–æ–∫!*"
			elif lang_data == 'uk':
				ck = "*–í–∏ —â–µ –Ω—ñ—á–æ–≥–æ –Ω–µ –∫—É–ø—É–≤–∞–ª–∏!*"
			else:
				ck = "*You didn't buy anything!*"
		else:
			for i in item:
				am += 1
				ck += f"{str(am)}. *{str(item[am-1])}* ({str(price[am-1])}‚Ç¥) | {str(date[am-1])}\n"
		await query.edit_message_text(f"üßæ {text}\n{ck}", parse_mode='Markdown', reply_markup=buttons)
	if query.data == 's_lang':
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		s_l_ru = "–†—É—Å—Å–∫–∏–π (ru)"
		s_l_uk = "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (uk)"
		s_l_en = "English (en)"
		if lang_data == 'ru':
			text = "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –¥–ª—è —Å–º–µ–Ω—ã"
			s_back = "–ù–∞–∑–∞–¥"
			keyboard = [
				[InlineKeyboardButton(f"üá∫üá¶ {s_l_uk}", callback_data="s_l_uk")],
				[InlineKeyboardButton(f"üá∫üá∏ {s_l_en}", callback_data="s_l_en")],
				[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="settings")],
			]
			buttons = InlineKeyboardMarkup(keyboard)
		elif lang_data == 'uk':
			text = "–í–∏–±–µ—Ä—ñ—Ç—å –º–æ–≤—É –¥–ª—è –∑–º—ñ–Ω–∏"
			s_back = "–ù–∞–∑–∞–¥"
			keyboard = [
				[InlineKeyboardButton(f"üá∑üá∫ {s_l_ru}", callback_data="s_l_ru")],
				[InlineKeyboardButton(f"üá∫üá∏ {s_l_en}", callback_data="s_l_en")],
				[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="settings")],
			]
			buttons = InlineKeyboardMarkup(keyboard)
		else:
			text = "Choose language to change"
			s_back = "Back"
			keyboard = [
				[InlineKeyboardButton(f"üá∑üá∫ {s_l_ru}", callback_data="s_l_ru")],
				[InlineKeyboardButton(f"üá∫üá¶ {s_l_uk}", callback_data="s_l_uk")],
				[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="settings")],
			]
			buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üá¶üá¶ {text}", parse_mode='Markdown', reply_markup=buttons)
	if "s_l_" in query.data:
		qdata = query.data
		qdsplit = qdata.split('_')
		q1 = qdsplit[0]
		q2 = qdsplit[1]
		q3 = qdsplit[2]
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		data[user]["lang"] = q3
		json.dump(data, open("database.json","w"))
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = "–Ø–∑—ã–∫ —É—Å–ø–µ—à–Ω–æ —Å–º–µ–Ω–µ–Ω –Ω–∞ "
			s_back = "–ù–∞–∑–∞–¥"
		elif lang_data == 'uk':
			text = "–ú–æ–≤–∞ —É—Å–ø—ñ—à–Ω–æ –∑–º—ñ–Ω–µ–Ω–∞ –Ω–∞ "
			s_back = "–ù–∞–∑–∞–¥"
		else:
			text = "Language successfully changed to "
			s_back = "Back"
		keyboard = [
			[InlineKeyboardButton(f"‚¨ÖÔ∏è {s_back}", callback_data="settings")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üá¶üá¶ {text}*{q3}*", parse_mode='Markdown', reply_markup=buttons)
	if "buycodes_" in query.data:
		qdata = query.data
		qdsplit = qdata.split('_')
		q1 = qdsplit[0]
		q2 = qdsplit[1]
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		lang_data = data[user]["lang"]
		if lang_data == 'ru':
			text = f"–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ –∫–æ–¥ –Ω–∞ *{q2}*‚Ç¥?"
			c_yes = "–î–∞"
			c_no = "–ù–µ—Ç"
			back = "–ü—Ä–æ—Ñ–∏–ª—å"
		elif lang_data == 'uk':
			text = f"–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ —â–æ —Ö–æ—á–µ—Ç–µ –∫—É–ø–∏—Ç–∏ –∫–æ–¥ –Ω–∞ *{q2}‚Ç¥*?"
			c_yes = "–¢–∞–∫"
			c_no = "–ù—ñ"
			back = "–ü—Ä–æ—Ñ—ñ–ª—å"
		else:
			text = f"Do you want buy code on *{q2}‚Ç¥*?"
			c_yes = "Yes"
			c_no = "No"
			back = "Profile"
		keyboard = [
			[InlineKeyboardButton(f"‚úÖ {c_yes}", callback_data=f"yes_buycode_{q2}"),
			InlineKeyboardButton(f"‚ùé {c_no}", callback_data="profile")],
		]
		buttons = InlineKeyboardMarkup(keyboard)
		await query.edit_message_text(f"üåê {text}", parse_mode='Markdown', reply_markup=buttons)
	if "yes_buycode_" in query.data:
		qdata = query.data
		qdsplit = qdata.split('_')
		q1 = qdsplit[0]
		q2 = qdsplit[1]
		q3 = qdsplit[2]
		try:
			user = context.user_data["user"]
		except:
			user = str(query.from_user.id)
		data = json.loads(open("database.json","r").read())
		shop = json.loads(open("shop.json","r").read())
		lang_data = data[user]["lang"]
		balance = data[user]["balance"]
		if lang_data == 'ru':
			error_money = '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ'
		elif lang_data == 'uk':
			error_money = '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∫–æ—à—Ç—ñ–≤ –Ω–∞ –±–∞–ª–∞–Ω—Å—ñ'
		else:
			error_money = "You don't have enough money"
		if lang_data == 'ru':
			profile = "–ü—Ä–æ—Ñ–∏–ª—å"
		elif lang_data == 'uk':
			profile = "–ü—Ä–æ—Ñ—ñ–ª—å"
		else:
			profile = "Profile"
		if balance < int(q3):
			keyboard = [
				[InlineKeyboardButton(f"üë§ {profile}", callback_data="profile")],
			]
			buttons = InlineKeyboardMarkup(keyboard)
			await query.edit_message_text(f"‚ùå {error_money}", parse_mode='Markdown', reply_markup=buttons)
		else:
			codename = ''
			for i in range(16):
				codename = codename + random.choice(list('1234567890abcdefghigklmnopqrstuvyxwzABCDEFGHIGKLMNOPQRSTUVYXWZ'))
			shop = json.loads(open("shop.json","r").read())
			data[user]["balance"] -= int(q3)
			a = shop["codes"]["code"]
			b = shop["codes"]["value"]
			c = shop["codes"]["amount"]
			d = shop["codes"]["com"]
			a.append(codename)
			b.append(int(q3))
			c.append(1)
			d.append(f"Created by {user}")
			shop["codes"]["code"] = a
			shop["codes"]["value"] = b
			shop["codes"]["amount"] = c
			shop["codes"]["com"] = d
			json.dump(data, open("database.json","w"))
			json.dump(shop, open("shop.json","w"))
			if lang_data == 'ru':
				text = f'–ö–æ–¥ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω: `{codename}`'
				b = f'–ë–∞–ª–∞–Ω—Å: *{str(data[user]["balance"])}*‚Ç¥'
			elif lang_data == 'uk':
				text = f'–ö–æ–¥ —É—Å–ø—ñ—à–Ω–æ —Å—Ç–≤–æ—Ä–µ–Ω: `{codename}`'
				b = f'–ë–∞–ª–∞–Ω—Å: *{str(data[user]["balance"])}‚Ç¥*'
			else:
				text = f'Code successfully created: `{codename}`'
				b = f'Balance: *{str(data[user]["balance"])}‚Ç¥*'
			await query.edit_message_text(f"‚òëÔ∏è {text}\nüí≥ {b}", parse_mode='Markdown', reply_markup=buttons)



#permission commands
async def test(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
		user = update.message.from_user
		chat = update.message.chat
		if user.id in testerID:
			await update.message.reply_text("tesr")
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

async def payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
		user = update.message.from_user
		chat = update.message.chat
		if user.id in adminID:
			text = update.message.text
			r = text.replace('/payment ', '')
			if r == '' or r == ' ' or r == '/payment':
				await update.message.reply_text("‚ùå Error! Write payment method")
			else:
				data_shop = json.loads(open("shop.json","r").read())
				if r in data_shop["payment"]["list"]:
					l = data_shop["payment"]["list"].index(r)
					if data_shop["payment"]["enabled"][l] == "False":
						data_shop["payment"]["enabled"][l] = "True"
						json.dump(data_shop, open("shop.json","w"))
						await update.message.reply_text(f"‚ùó *{r}* changed from *False* to *True*", parse_mode='Markdown')
					else:
						data_shop["payment"]["enabled"][l] = "False"
						json.dump(data_shop, open("shop.json","w"))
						await update.message.reply_text(f"‚ùó *{r}* changed from *True* to *False*", parse_mode='Markdown')
				else:
					await update.message.reply_text(f"‚ùó *{r}* not found in *shop.json*", parse_mode='Markdown')
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

async def database(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
		user = update.message.from_user
		chat = update.message.chat
		if user.id in adminID:
			text = "üõ† Choose type of database\nüõç *Shop* _(1)_\nüë• *User* _(2)_"
			if user.id == ownerID:
				text += "\nüñ• *Config* _(3)_"
			await update.message.reply_text(f"{text}", parse_mode='Markdown')
			return DATABASE_TYPE
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

async def database_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
		user = update.message.from_user
		chat = update.message.chat
		message = update.message.text
		if user.id in adminID:
			if message in ["1", "Shop"]:
				text = "üõç Choose shop data type:\nüçé *Items* _(1)_\nüåê *Codes* _(2)_\n_üí∏ *Payment* _(3)_"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return DATABASE_SHOP
			elif message in ["2", "User", "Users", "Userdata"]:
				text = "üë• Write user ID\n‚ùó Arguments: `all`"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return DATABASE_USER
			elif message in ["3", "Config", "Configuration"] and user.id == ownerID:
				text = "üñ• Download *config.txt* and send me edited *config.txt*"
				await update.message.reply_document(open("config.txt", 'rb'), caption=f"{text}", parse_mode='Markdown')
				return DATABASE_CONFIG
			else:
				text = "‚ùå Unkown type: `"+message+"`"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

async def database_shop(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
		user = update.message.from_user
		chat = update.message.chat
		message = update.message.text
		if user.id in adminID:
			if message in ["1", "Items", "Item"]:
				text = "üõç Choose items data:\nüçé *Item* _(1)_\nü™ô *Price* _(2)_\nüí± *Discount* _(3)_\nüî¢ *Amount* _(4)_\n„Ä∞Ô∏è *Comment*:  _(4)_\nüìù *Purchase tutorial*: _(5)_"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return DATABASE_ITEMS
			elif message in ["2", "Codes", "Code"]:
				text = "üåê Choose code data:\nüçè *Code* _(1)_\nü™ô *Value* _(2)_\nüî¢ *Amount* _(3)_\n„Ä∞Ô∏è *Comment*:  _(4)_"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return DATABASE_CODES
			elif message in ["3", "Payment", "Pay"]:
				text = "üí∏ Choose payment data:\nüìî *List of payments* _(1)_\n‚úîÔ∏è *Toggle* _(2)_"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return DATABASE_PAYMENT
			else:
				text = "‚ùå Unkown type: `"+message+"`"
				await update.message.reply_text(f"{text}", parse_mode='Markdown')
				return
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

MAILINGTEXT, MAILINGFORWARD = range(2)

async def mailing(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
		user = update.message.from_user
		chat = update.message.chat
		if user.id in adminID:
			await update.message.reply_text('üè¥ *Okay!*\nüí¨ Now send me text to mail or write `r!forward` for forward mailing', parse_mode='Markdown')
			return MAILINGTEXT
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

async def mailingtext(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
		user = update.message.from_user
		chat = update.message.chat
		if user.id in adminID:
			text = update.message.text
			if text == 'r!forward':
				await update.message.reply_text('üè¥ *Good!* Now send me message to forward', parse_mode='Markdown')
				return MAILINGFORWARD
			data = json.loads(open("database.json","r").read())
			try:
				us = 0
				for i in data:
					await context.bot.send_message(chat_id=i, text=text)
					us = i
			except:	
				await update.message.reply_text('‚ùå *Error!* Message not delivered to `'+str(us)+'`', parse_mode='Markdown')
				data.remove(us)
			await update.message.reply_text('‚úÖ *Done!*\nüó£Ô∏è Message sended to', parse_mode='Markdown')
			return ConversationHandler.END
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

async def mailingforward(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
		user = update.message.from_user
		chat = update.message.chat
		if user.id in adminID:
			user_data = context.user_data
			type = user_data["mailingtype"]
			text = update.message.text
			data = json.loads(open("database.json","r").read())
			try:
				from_chat = chat.id
				message_id = update.message.id
				us = 0
				for i in data:
					await context.bot.forward_message(chat_id=i, from_chat_id=from_chat, message_id=message_id)
					us = i
			except:
				await update.message.reply_text('‚ùå *Error!* Message not forwarded to `'+str(us)+'`', parse_mode='Markdown')
			await update.message.reply_text('‚úÖ *Done!*\nüó£Ô∏è Message forwarded', parse_mode='Markdown')
			return ConversationHandler.END
		else:
			await update.message.reply_text(f"‚ùå Access error!\n‚ùóYou (`{user.id}`) don't have permission to use this command", parse_mode='Markdown')

CAPTCHA = range(1)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	#Send message when "/start" issued
	ef = update.effective_user
	data = json.loads(open("database.json","r").read())
	user = str(update.message.from_user.id)
	if user not in data:
		nickname = update.message.from_user.username
		id = update.message.from_user.id
		lang = update.message.from_user.language_code
		if lang == 'ru':
			text = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–π–¥–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É —Å –ø–æ–º–æ—â—å—é –∫–∞–ø—á–∏"
		elif lang == 'uk':
			text = "–ë—É–¥—å –ª–∞—Å–∫–∞, –ø—Ä–æ–π–¥—ñ—Ç—å –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∫–∞–ø—á–∏"
		else:
			text = "Please, write captcha"
		try:
			if context.user_data["captcha"] != "":
				context.user_data["captcha"] = "0"
		except:
			context.user_data["captcha"] = "0"
		if context.user_data["captcha"] == "0":
			pattern = ""
			for x in range(random.randrange(6, 12)):
				pattern = pattern + random.choice(list('1234567890abcdefghigklmnopqrstuvyxwzABCDEFGHIGKLMNOPQRSTUVYXWZ'))
			captchaimg = ImageCaptcha(width=random.randrange(200, 400), height=random.randrange(200, 400))
			captchaimg.write(pattern, "captcha.png")
			context.user_data["captcha"] = pattern
			await update.message.reply_photo(open("captcha.png", 'rb'), caption=f"üõ° {text}", parse_mode='Markdown')
			return CAPTCHA
		from datetime import date
		today = date.today()
		today = str(today)
		data[user] = {
			"balance":0,
			"transactions":{
				"item":["Registration"],
				"price":[0],
				"date":[f"{today}"]
			},
			"pubId":[],
			"bans":[],
			"codes":[],
			"lang":lang
		}
		#save
		json.dump(data, open("database.json","w"))
	data = json.loads(open("database.json","r").read())
	balance = data[user]["balance"]
	transaction = data[user]["transactions"]
	lang = data[user]["lang"]
	if lang == 'ru':
		text = f'üëã –ü—Ä–∏–≤–µ—Ç, {ef.mention_html()}!\nüìÉ –ò—Å–ø–æ–ª—å–∑—É–π "/profile" —á—Ç–æ–± –Ω–∞—á–∞—Ç—å –ø–æ–∫—É–ø–∞—Ç—å!'
	elif lang == 'uk':
		text = f'üëã –ü—Ä–∏–≤—ñ—Ç, {ef.mention_html()}!\nüìÉ –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π "/profile" —â–æ–± –ø–æ—á–∞—Ç–∏ –∫—É–ø—É–≤–∞—Ç–∏!'
	else:
		text = f'üëã Hello, {ef.mention_html()}!\nüìÉ Use "/profile" for start shopping!'
	await update.message.reply_html(text, reply_markup=ForceReply(selective=True, input_field_placeholder="/profile"),
	)

async def captcha(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	#Send message when "/start" issued
	lang = update.message.from_user.language_code
	message = update.message.text
	if lang == 'ru':
		correct = "*–í–µ—Ä–Ω–æ!* –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ */start* —Å–Ω–æ–≤–∞"
		not_correct = "*–ù–µ –≤–µ—Ä–Ω–æ!* –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞"
	elif lang == 'uk':
		correct = "*–í—ñ—Ä–Ω–æ!* –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ */start* –∑–Ω–æ–≤—É"
		not_correct = "*–ù–µ –≤—ñ—Ä–Ω–æ!* –ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ –∑–Ω–æ–≤—É"
	else:
		correct = "*Correct!* Please, use */start* again"
		not_correct = "*Not correct!* Please, try again"
	if message.lower() != context.user_data["captcha"].lower():
		pattern = ""
		for x in range(random.randrange(6, 12)):
			pattern = pattern + random.choice(list('1234567890abcdefghigklmnopqrstuvyxwzABCDEFGHIGKLMNOPQRSTUVYXWZ'))
		captchaimg = ImageCaptcha(width=random.randrange(200, 400), height=random.randrange(200, 400))
		captchaimg.write(pattern, "captcha.png")
		context.user_data["captcha"] = pattern
		await update.message.reply_photo(open("captcha.png", 'rb'), caption=f"‚ùå {not_correct}", parse_mode='Markdown')
		return
	else:
		context.user_data["captcha"] = ""
		await update.message.reply_text(f'‚úÖ {correct}', parse_mode='Markdown')
		return ConversationHandler.END

async def help(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	if user not in data:
		return
	us = update.message.from_user
	lang = data[user]["lang"]
	if lang == 'ru':
		text = '‚ùî <b>–ü–æ–º–æ—â—å</b>\nüè¥ –ß—Ç–æ–± –ø–æ–ø–∞—Å—Ç—å –≤ –ø—Ä–æ—Ñ–∏–ª—å –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ <b>–∫–Ω–æ–ø–∫—É</b> –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ <b>/profile</b>\nüè¥ –ï—Å–ª–∏ –∫–∞–∫–æ–≥–æ –ª–∏–±–æ —Å–ø–æ—Å–æ–±–∞ –Ω–µ—Ç—É - –∑–Ω–∞—á–∏—Ç –µ–≥–æ –≤—ã–∫–ª—é—á–∏–ª–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ\nüè¥ –ü—Ä–æ–±–ª–µ–º—ã? –ü–∏—à–∏—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∫–µ –∏—Å–ø–æ–ª—å–∑—É—è <b>/support</b>\nüè¥ –ï—Å—Ç—å –∫–æ–¥? –ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –µ–≥–æ –∏—Å–ø–æ–ª—å–∑—É—è <b>/codes</b>'
		profile = '–ü—Ä–æ—Ñ–∏–ª—å'
	elif lang == 'uk':
		text = '‚ùî <b>–î–æ–ø–æ–º–æ–≥–∞</b>\nüè¥ –©–æ–± –ø–æ–ø–∞—Å—Ç–∏ —É –ø—Ä–æ—Ñ—ñ–ª—å –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ <b>–∫–Ω–æ–ø–∫—É</b> –Ω–∏–∂—á–µ –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å <b>/profile</b>\nüè¥ –Ø–∫—â–æ –¥–µ—è–∫–æ–≥–æ —Å–ø–æ—Å—ñ–±–∞ –æ–ø–ª–∞—Ç–∏ –Ω–µ–º–∞—î - –∑–Ω–∞—á–∏—Ç—å –π–æ–≥–æ –≤–∏–º–∫–Ω—É–ª–∏, —Å–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ\nüè¥ –ü—Ä–æ–±–ª–µ–º–∏? –ü–∏—à—ñ—Ç—å –ø—ñ–¥—Ç—Ä–∏–º—Ü—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—è <b>/support</b>\nüè¥ –Ñ –∫–æ–¥? –ê–∫—Ç–∏–≤—É–π—Ç–µ –π–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—è <b>/codes</b>'
		profile = '–ü—Ä–æ—Ñ—ñ–ª—å'
	else:
		text = '‚ùî <b>Help</b>\nüè¥ To get in profile, use <b>button</b> below or write <b>/profile</b>\nüè¥ If one of payment methods is not found - this method is off, try later\nüè¥ Problems? Write to support using <b>/support</b>\nüè¥ Do you have code? Activate it using <b>/codes</b>'
		profile = 'Profile'
	keyboard = [
		[InlineKeyboardButton(f"üë§ {profile}", callback_data="profile")],
	]
	buttons = InlineKeyboardMarkup(keyboard)
	await update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=buttons)

async def profile(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	us = update.message.from_user
	lang = update.message.from_user.language_code
	if user not in data:
		nickname = update.message.from_user.username
		id = update.message.from_user.id
		lang = update.message.from_user.language_code
		if lang not in ['ru', 'uk']:
			lang = 'en'
		from datetime import date
		today = date.today()
		today = str(today)
		data[user] = {
			"balance":0,
			"transactions":{
				"item":["Registration"],
				"price":[0],
				"date":[f"{today}"]
			},
			"pubId":[],
			"bans":[],
			"codes":[],
			"lang":lang
		}
		#save
		json.dump(data, open("database.json","w"))
	data = json.loads(open("database.json","r").read())
	balance = data[user]["balance"]
	transaction = data[user]["transactions"]
	item = transaction["item"]
	price = transaction["price"]
	item = item[len(item)-1]
	price = price[len(price)-1]
	lang = data[user]["lang"]
	if lang == 'ru':
		refill = "–ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å"
		shop = "–ú–∞–≥–∞–∑–∏–Ω"
		settings = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏"
		text = f'üåÄ –¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å\nüë§ –ù–∏–∫: <b>{us.username}</b>\nüÜî –ê–π–¥–∏: <b>{us.id}</b>\nüí≥ –ë–∞–ª–∞–Ω—Å: <b>{balance}</b>‚Ç¥\nüìë –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è: <b>{item}</b> ({price}‚Ç¥)\nüá∑üá∫ –Ø–∑—ã–∫: <b>{lang}</b>'
	elif lang == 'uk':
		refill = "–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å"
		shop = "–ú–∞–≥–∞–∑–∏–Ω"
		settings = "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è"
		text = f'üåÄ –¢–≤—ñ–π –ø—Ä–æ—Ñ—ñ–ª—å\nüë§ –ù—ñ–∫: <b>{us.username}</b>\nüÜî –ê–π–¥—ñ: <b>{us.id}</b>\nüí≥ –ë–∞–ª–∞–Ω—Å: <b>{balance}</b>‚Ç¥\nüìë –û—Å—Ç–∞–Ω–Ω—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è: <b>{item}</b> ({price}‚Ç¥)\nüá∫üá¶ –ú–æ–≤–∞: <b>{lang}</b>'
	else:
		refill = "Refill balance"
		shop = "Shop"
		settings = "Settings"
		text = f'üåÄ Your profile\nüë§ Nickname: <b>{us.username}</b>\nüÜî ID: <b>{us.id}</b>\nüí≥ Balance: <b>{balance}</b>‚Ç¥\nüìë Last transaction: <b>{item}</b> ({price}‚Ç¥)\nüá∫üá∏ Language: <b>{lang}</b>'
	profilekeyboard = [
		[InlineKeyboardButton(f"üí∏ {refill}", callback_data="refillbalance")],
		[InlineKeyboardButton(f"üõç {shop}", callback_data="shop")],
		[InlineKeyboardButton(f"‚öôÔ∏è {settings}", callback_data="settings")],
	]
	profilebuttons = InlineKeyboardMarkup(profilekeyboard)
	await update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=profilebuttons)

SUPPORTTEXT = range(1)

async def support(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	if user not in data:
		return
	us = update.message.from_user
	message = update.message.text
	lang = data[user]["lang"]
	bans = data[user]["bans"]
	if lang == 'ru':
		text = "üëæ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–∏—à–∏—Ç–µ –≤–∞—à—É –ø—Ä–æ–±–ª–µ–º—É –∫–∞–∫ –º–æ–∂–Ω–æ –¥–µ—Ç–∞–ª—å–Ω–µ–µ –∏ –º—ã –¥–∞–¥–∏–º –≤–∞–º –æ—Ç–≤–µ—Ç –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏\n‚ùó –û—Ç–º–µ–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –º–æ–∂–Ω–æ –ø—Ä–∏ –ø–æ–º–æ—â–∏ */cancel*"
		ban = "üëæ –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
	elif lang == 'uk':
		text = "üëæ –ë—É–¥—å –ª–∞—Å–∫–∞, –æ–ø–∏—à—ñ—Ç—å –≤–∞—à—É –ø—Ä–æ–±–ª–µ–º—É —è–∫ –º–æ–∂–Ω–∞ –¥–µ—Ç–∞–ª—å–Ω—ñ—à–µ —ñ –º–∏ –¥–∞–º–æ –≤–∞–º –≤—ñ–¥–ø–æ–≤—ñ–¥—å –ø—Ä–∏ –ø–µ—Ä—à—ñ–π –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ\n‚ùó –í—ñ–¥–º–∏–Ω–∏—Ç–∏ –∫–æ–º–∞–Ω–¥—É –º–æ–∂–Ω–∞ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é */cancel*"
		ban = "üëæ –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
	else:
		text = "üëæ Please, write your problems with more details and we send feedback when it was can be\n‚ùó You can cancel command by */cancel*"
		ban = "üëæ Sorry, but you are banned"
	if "support" not in bans:
		await update.message.reply_text(text, parse_mode='Markdown')
		return SUPPORTTEXT
	else:
		await update.message.reply_text(ban, parse_mode='Markdown')
		return ConversationHandler.END

async def supporttext(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	us = update.message.from_user
	message = update.message.text
	lang = data[user]["lang"]
	bans = data[user]["bans"]
	if lang == 'ru':
		text = "üëæ –°–ø–∞—Å–∏–±–æ, –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ"
		ban = "üëæ –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
	elif lang == 'uk':
		text = "üëæ –î—è–∫—É—é, –≤–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –±—É–ª–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ"
		ban = "üëæ –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
	else:
		text = "üëæ Thanks, your message was delivered"
		ban = "üëæ Sorry, but you are banned"
	if "support" not in bans:
		message = f"üëæ Message to support from {user}\nüá¶üá¶ Language: {lang}"
		await context.bot.send_message(ownerID, text=message)
		await context.bot.forward_message(chat_id=ownerID, from_chat_id=update.effective_chat.id, message_id=update.effective_message.id)
		await update.message.reply_text(text, parse_mode='Markdown')
		return ConversationHandler.END
	else:
		await update.message.reply_text(ban, parse_mode='Markdown')
		return ConversationHandler.END

CODESCHOOSE, CODESUSE = range(2)

async def codes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	if user not in data:
		return
	us = update.message.from_user
	message = update.message.text
	lang = data[user]["lang"]
	bans = data[user]["bans"]
	if lang == 'ru':
		text = "üåê –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ\nüè∑ _(1)_ *use* - –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–¥\nü™Ñ _(2)_ *buy* - –ö—É–ø–∏—Ç—å –∫–æ–¥\n‚ùó */cancel* - –û—Ç–º–µ–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É"
		ban = "üåê –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
	elif lang == 'uk':
		text = "üåê –û–±–µ—Ä—ñ—Ç—å –¥—ñ—é\nüè∑ _(1)_ *use* - –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –∫–æ–¥\nü™Ñ _(2)_ *buy* - –ö—É–ø–∏—Ç–∏ –∫–æ–¥\n‚ùó */cancel* - –í—ñ–¥–º—ñ–Ω–∏—Ç–∏ –∫–æ–º–∞–Ω–¥—É"
		ban = "üåê –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
	else:
		text = "üåê Choose action\nüè∑ _(1)_ *use* - Use code\nü™Ñ _(2)_ *buy* - By code\n‚ùó */cancel* - Cancel command"
		ban = "üåê Sorry, but you are banned"
	if "codes" not in bans:
		await update.message.reply_text(text, parse_mode='Markdown')
		return CODESCHOOSE
	else:
		await update.message.reply_text(ban, parse_mode='Markdown')
		return ConversationHandler.END

async def codeschoose(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	
	keyboard = [
	[
		InlineKeyboardButton("25‚Ç¥", callback_data="buycodes_25"),
		InlineKeyboardButton("50‚Ç¥", callback_data="buycodes_50")
	],
	[
		InlineKeyboardButton("75‚Ç¥", callback_data="buycodes_75"),
		InlineKeyboardButton("100‚Ç¥", callback_data="buycodes_100")
	],
	]
	buttons = InlineKeyboardMarkup(keyboard)
	
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	us = update.message.from_user
	message = update.message.text
	lang = data[user]["lang"]
	bans = data[user]["bans"]
	if lang == 'ru':
		use = "üåê –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥\n‚ùó */cancel* - –û—Ç–º–µ–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É"
		buy = "üåê –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∏–∂–µ"
		error = f"üåê –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ: *{message}*\n‚ùó */cancel* - –û—Ç–º–µ–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É"
		ban = "üåê –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
	elif lang == 'uk':
		use = "üåê –ù–∞–ø–∏—à—ñ—Ç—å –∫–æ–¥\n‚ùó */cancel* - –í—ñ–¥–º—ñ–Ω–∏—Ç–∏ –∫–æ–º–∞–Ω–¥—É"
		buy = "üåê –û–±–µ—Ä—ñ—Ç—å —Ü—ñ–Ω—É –Ω–∏–∂—á–µ"
		error = f"üåê –ù–µ–≤—ñ–¥–æ–º–∞ –¥—ñ—è: *{message}*\n‚ùó */cancel* - –í—ñ–¥–º—ñ–Ω–∏—Ç–∏ –∫–æ–º–∞–Ω–¥—É"
		ban = "üåê –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
	else:
		use = "üåê Write code\n‚ùó */cancel* - Cancel command"
		buy = "üåê Choose price below"
		error = f"üåê Unknown action: *{message}*\n‚ùó */cancel* - Cancel command"
		ban = "üåê Sorry, but you are banned"
	if "codes" not in bans:
		if message in ["1", "use"]:
			await update.message.reply_text(use, parse_mode='Markdown')
			return CODESUSE
		elif message in ["2", "buy"]:
			await update.message.reply_text(buy, parse_mode='Markdown', reply_markup=buttons)
			return ConversationHandler.END
		else:
			await update.message.reply_text(error, parse_mode='Markdown')
			return
	else:
		await update.message.reply_text(ban, parse_mode='Markdown')
		return ConversationHandler.END

async def codesuse(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	shop = json.loads(open("shop.json","r").read())
	us = update.message.from_user
	message = update.message.text
	lang = data[user]["lang"]
	bans = data[user]["bans"]
	if lang == 'ru':
		ban = "üåê –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
	elif lang == 'uk':
		ban = "üåê –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
	else:
		ban = "üåê Sorry, but you are banned"
	if "codes" not in bans:
		Scode = shop["codes"]["code"]
		l = len(Scode)
		err = 0
		for i in range(len(shop["codes"]["code"])):
			Scode = shop["codes"]["code"][i]
			Svalue = shop["codes"]["value"][i]
			Samount = shop["codes"]["amount"][i]
			Scom = shop["codes"]["com"][i]
			if Scode != message:
				err += 1
			else:
				break
		if lang == 'ru':
			successfully = "‚úÖ –ö–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ"
			error_not_found = "‚ùå –ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω"
			error_max = "‚ùå –ö–æ–¥ –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω"
			error_used = "‚ùå –ö–æ–¥ —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω"
			reward = f"üí∞ –¢–≤–æ—è –Ω–∞–≥—Ä–∞–¥–∞: *{Svalue}‚Ç¥*"
			ban = "üåê –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
		elif lang == 'uk':
			successfully = "‚úÖ –ö–æ–¥ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω —É—Å–ø—ñ—à–Ω–æ"
			error_not_found = "‚ùå –ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω"
			error_max = "‚ùå –ö–æ–¥ –±—ñ–ª—å—à–µ –Ω–µ –¥—ñ–π—Å–Ω–∏–π"
			error_used = "‚ùå –ö–æ–¥ –≤–∂–µ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–∏–π"
			reward = f"üí∞ –¢–≤–æ—è –Ω–∞–≥–æ—Ä–æ–¥–∞: *{Svalue}‚Ç¥*"
			ban = "üåê –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
		else:
			successfully = "‚úÖ Code activated successfully"
			error_not_found = "‚ùå Code not found"
			error_max = "‚ùå Code is expired"
			error_used = "‚ùå Code already used"
			reward = f"üí∞ Your reward: *{Svalue}‚Ç¥*"
			ban = "üåê Sorry, but you are banned"
		a = data[user]["codes"]
		if err == l:
			await update.message.reply_text(error_not_found, parse_mode='Markdown')
			return
		if message not in shop["codes"]["code"]:
			await update.message.reply_text(error_not_found, parse_mode='Markdown')
			return
		if message in data[user]["codes"]:
			await update.message.reply_text(error_used, parse_mode='Markdown')
			return
		if Samount == 0:
			await update.message.reply_text(error_max, parse_mode='Markdown')
			return
		if Scode in a:
			await update.message.reply_text(error_used, parse_mode='Markdown')
			return
		a = data[user]["codes"]
		a.append(Scode)
		data[user]["balance"] += Svalue
		data[user]["codes"] = a
		if Samount != -1:
			l = shop["codes"]["code"].index(Scode)
			shop["codes"]["amount"][l] -= 1
		json.dump(data, open("database.json","w"))
		json.dump(shop, open("shop.json","w"))
		await update.message.reply_text(f"{successfully}\n{reward}\n_{Scom}_", parse_mode='Markdown')
		return ConversationHandler.END
	else:
		await update.message.reply_text(ban, parse_mode='Markdown')
		return ConversationHandler.END

async def codesbuy(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	user = str(update.message.from_user.id)
	context.user_data["user"] = user
	data = json.loads(open("database.json","r").read())
	shop = json.loads(open("shop.json","r").read())
	us = update.message.from_user
	message = update.message.text
	lang = data[user]["lang"]
	bans = data[user]["bans"]
	if lang == 'ru':
		text = "üåê –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∏–∂–µ"
		ban = "üåê –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–æ –≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã"
	elif lang == 'uk':
		text = "üåê –û–±–µ—Ä—ñ—Ç—å —Ü—ñ–Ω—É –Ω–∏–∂—á–µ"
		ban = "üåê –í–∏–±–∞—á—Ç–µ, –∞–ª–µ –≤–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ"
	else:
		text = "üåê Choose price below"
		ban = "üåê Sorry, but you are banned"
	if "codes" not in bans:
		keyboard = [
		[
			[InlineKeyboardButton(f"25‚Ç¥", callback_data="buycodes_25")],
			[InlineKeyboardButton(f"50‚Ç¥", callback_data="buycodes_50")],
			[InlineKeyboardButton(f"75‚Ç¥", callback_data="buycodes_75")],
			[InlineKeyboardButton(f"100‚Ç¥", callback_data="buycodes_100")],
		],
		[
			[InlineKeyboardButton(f"250‚Ç¥", callback_data="buycodes_250")],
			[InlineKeyboardButton(f"500‚Ç¥", callback_data="buycodes_500")],
			[InlineKeyboardButton(f"750‚Ç¥", callback_data="buycodes_750")],
			[InlineKeyboardButton(f"1000‚Ç¥", callback_data="buycodes_1000")],
		]
	]
		buttons = InlineKeyboardMarkup(keyboard)
		await update.message.reply_text(text, parse_mode='Markdown', reply_markup=buttons)
		return ConversationHandler.END
	else:
		await update.message.reply_text(ban, parse_mode='Markdown')
		return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
	await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.effective_message.id-1)
	await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.effective_message.id)
	return ConversationHandler.END

#async def userecho(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#	#Echo users message
#	await update.message.reply_text(update.message.text)


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
	#Log the error and send a telegram message to notify the developer.
	#Log the error before we do anything else, so we can see it even if something breaks.
	logger.error(msg="Exception while handling an update:", exc_info=context.error)

	#Traceback.format_exception returns the usual python message about an exception, but as a list of strings rather than a single string, so we have to join them together.
	tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
	tb_string = "".join(tb_list)

	#Build the message with some markup and additional information about what happened.
	#You might need to add some logic to deal with messages longer than the 4096 character limit.
	update_str = update.to_dict() if isinstance(update, Update) else str(update)
	message = (
		f"PTB: {TG_VER} | BOT: {version}"
		f"\nAn exception was raised while handling an update\n"
		f"<pre>update = {html.escape(json.dumps(update_str, indent=2, ensure_ascii=False))}"
		"</pre>\n\n"
		f"<pre>context.chat_data = {html.escape(str(context.chat_data))}</pre>\n\n"
		f"<pre>context.user_data = {html.escape(str(context.user_data))}</pre>\n\n"
		f"<pre>{html.escape(tb_string)}</pre>"
	)

	#Finally, send the message
	#user = update.effective_message.user_id
	await update.message.reply_text(
		text='‚ùóError log sended to owner!', parse_mode=ParseMode.HTML
	)
	await context.bot.send_message(
		chat_id=ownerID, text=message, parse_mode=ParseMode.HTML
	)

def main() -> None:
	#Start bot
	#Create the Application and pass it your bot's token.
	application = Application.builder().token(TelegramBotToken).build()

	#On different commands - answer in Telegram
	if onUpdate == False:
		#query
		application.add_handler(CallbackQueryHandler(querybuttons))
		mailingconv = ConversationHandler(
			entry_points=[CommandHandler("mailing", mailing)],
			states={
				MAILINGTEXT: [MessageHandler(filters.TEXT & ~filters.COMMAND, mailingtext)],
				MAILINGFORWARD: [MessageHandler(filters.ALL, mailingforward)],
			},
			fallbacks=[CommandHandler("cancel", cancel)],
		)
		application.add_handler(mailingconv)
		#permissions
		application.add_handler(CommandHandler("test", test))
		application.add_handler(CommandHandler("payment", payment))
		#default
		#application.add_handler(CommandHandler("start", start))
		startconv = ConversationHandler(
			entry_points=[CommandHandler("start", start)],
			states={
				CAPTCHA: [MessageHandler(filters.ALL, captcha)],
			},
			fallbacks=[CommandHandler("start", start)],
		)
		application.add_handler(startconv)
		application.add_handler(CommandHandler("help", help))
		application.add_handler(CommandHandler(["profile", "account"], profile))
		supportconv = ConversationHandler(
			entry_points=[CommandHandler("support", support)],
			states={
				SUPPORTTEXT: [MessageHandler(filters.ALL & ~filters.COMMAND, supporttext)],
			},
			fallbacks=[CommandHandler("cancel", cancel)],
		)
		application.add_handler(supportconv)
		codesconv = ConversationHandler(
			entry_points=[CommandHandler(["codes", "code"], codes)],
			states={
				CODESCHOOSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, codeschoose)],
				CODESUSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, codesuse)],
			},
			fallbacks=[CommandHandler("cancel", cancel)],
		)
		application.add_handler(codesconv)
	else:
		application.add_handler(MessageHandler(filters.COMMAND, onUpdate))

	application.add_error_handler(error_handler)

	#On non command i.e message - echo the message on Telegram
#	application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, userecho))

	#Run the bot until the user presses Ctrl-C
	application.run_polling()


if __name__ == "__main__":
	main()